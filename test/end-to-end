#!/usr/bin/env ruby
require "securerandom"
require "minitest/autorun"
require_relative "test_helper"

rafka = (ENV["RAFKA"] || "localhost:6380").split(":")
HOST, PORT = rafka[0], Integer(rafka[1])
TOPIC = ENV["DOCKER"] ? "test-rafka-#{Time.now.to_i}-#{SecureRandom.hex(6)}" : "test-rafka"
FLUSH_TIMEOUT = 5000
CONSUME_RETRIES = 3

require "bundler/inline"
gemfile(true) do
  source 'https://rubygems.org'
  gem "rafka", git: "https://github.com/skroutz/rafka-rb"
  gem "minitest"
  gem "pry-byebug"
end

class TestRafka < Minitest::Test
  DEFAULTS = { host: HOST, port: PORT }

  def setup
    @cons = Rafka::Consumer.new(DEFAULTS.merge(
      topic: TOPIC, group: "test-#{SecureRandom.hex(6)}", id: SecureRandom.hex(4)))
    @prod = Rafka::Producer.new(DEFAULTS)
  end

  def test_consume_single
    start_consumer!(@cons)

    produce_and_flush!(@prod, TOPIC, "huhu")

    msg = consume_with_retry(@cons)
    assert_equal "huhu", (msg && msg.value)
  end

  def test_consume_many
    start_consumer!(@cons)

    3.times { |i| @prod.produce(TOPIC, i) }
    flush!(@prod)

    replies = []
    3.times do |i|
      msg = consume_with_retry(@cons)
      if !(msg && msg.value =~ /\A\d\z/)
        flunk("Unexpected reply: #{msg.inspect}. Replies so far: #{replies.inspect}")
      end
      replies << msg.value
    end

    assert_equal ["0", "1", "2"], replies.sort
    assert_nil @cons.consume(1)
  end

  def test_producer_flush
    5.times { @prod.produce(TOPIC, "foo") }
    assert_equal 0, @prod.flush(FLUSH_TIMEOUT)
  end

  # TODO(agis): fix occassional failures
  def test_multiple_consumers_same_topic
    group_id = SecureRandom.hex(6)
    cons1 = Rafka::Consumer.new(DEFAULTS.merge(topic: TOPIC, group: group_id, id: "cons1"))
    cons2 = Rafka::Consumer.new(DEFAULTS.merge(topic: TOPIC, group: group_id, id: "cons2"))
    start_consumer!(cons1)
    start_consumer!(cons2)

    msgs = Array.new(2) { SecureRandom.hex(4) }

    # produce it
    msgs.each { |msg| @prod.produce(TOPIC, msg) }
    flush!(@prod)

    # consume it
    replies = []
    2.times do
      msg = consume_with_retry(cons1)
      break if !msg
      replies << msg.value
    end

    if replies.size < 2
      2.times do
        msg = consume_with_retry(cons2)
        replies << msg.value if msg
        break if replies.size == 2
      end
    end

    assert_equal msgs.sort, replies.sort
  end

  # TODO(agis): fix occassional failures
  def test_consumer_reassign
    group_id = SecureRandom.hex(6)
    cons1 = Rafka::Consumer.new(DEFAULTS.merge(topic: TOPIC, group: group_id, id: "cons1"))
    cons2 = Rafka::Consumer.new(DEFAULTS.merge(topic: TOPIC, group: group_id, id: "cons2"))

    start_consumer!(cons1)
    msg = SecureRandom.hex(4)
    produce_and_flush!(@prod, TOPIC, msg)
    assert_rafka_msg_equal msg, consume_with_retry(cons1)

    cons1.quit # so that cons2 gets all the partitions

    start_consumer!(cons2)
    msg = SecureRandom.hex(4)
    produce_and_flush!(@prod, TOPIC, msg)
    assert_rafka_msg_equal msg, consume_with_retry(cons2)
  end

  def test_two_consumers_different_topics
    cons2 = Rafka::Consumer.new(DEFAULTS.merge(topic: TOPIC+"-2", group: "asdf"))
    start_consumer!(cons2)
    start_consumer!(@cons)

    @prod.produce(TOPIC, "I'm Mr. Meeseeks")
    @prod.produce(TOPIC+"-2", "Look at me")
    flush!(@prod)

    assert_rafka_msg_equal "I'm Mr. Meeseeks", consume_with_retry(@cons)
    assert_rafka_msg_equal "Look at me", consume_with_retry(cons2)
  end if ENV["DOCKER"]

  def test_produce_wrong_topic
    @prod.produce("idontexist", "foo")
    binding.pry
    1
  end
end

puts "\nRunning tests on #{HOST}:#{PORT} (CONSUME_RETRIES=#{CONSUME_RETRIES})..."

if ENV["DOCKER"]
  create_kafka_topic!(TOPIC, partitions: 4, replication_factor: 2)
  create_kafka_topic!(TOPIC+"-2", partitions: 4, replication_factor: 2)

  MiniTest.after_run do
    delete_kafka_topic!(TOPIC)
    delete_kafka_topic!(TOPIC+"-2")
  end
end
