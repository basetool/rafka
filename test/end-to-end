#!/usr/bin/env ruby
ENV["BUNDLE_GEMFILE"] ||= File.expand_path("Gemfile", File.dirname(__FILE__))

require "bundler/setup"
Bundler.setup(:default)
require "securerandom"
require "minitest/autorun"
require "rafka"
require_relative "test_helper"

host_port = (ENV["RAFKA"] || "localhost:6380").split(":")
host, port = host_port[0], Integer(host_port[1])

CLIENT_DEFAULTS = { host: host, port: port }
FLUSH_TIMEOUT = 5000
CONSUME_RETRIES = 4
CONSUME_TIMEOUT = 3

class TestRafka < Minitest::Test
  def setup
    @prod = Rafka::Producer.new(CLIENT_DEFAULTS)
  end

  def test_consume_many
    with_new_topic(consumer: true) do |topic, cons|
      start_consumer!(cons)

      3.times { |i| @prod.produce(topic, i) }
      flush!(@prod)

      replies = []
      3.times do |i|
        msg = consume_with_retry(cons)
        assert_rafka_msg msg
        replies << msg.value
      end

      assert_equal ["0", "1", "2"], replies.sort
    end
  end

  def test_many_consumers_same_topic
    with_new_topic do |topic|
      group_id = rand_id(:cgroup)
      cons1 = Rafka::Consumer.new(CLIENT_DEFAULTS.merge(topic: topic, group: group_id, id: "cons1"))
      cons2 = Rafka::Consumer.new(CLIENT_DEFAULTS.merge(topic: topic, group: group_id, id: "cons2"))
      start_consumer!(cons1)
      start_consumer!(cons2)

      msgs = ["a", "b"]
      msgs.each { |msg| @prod.produce(topic, msg) }
      flush!(@prod)

      replies = []
      tries = 0

      while replies.size < 2 && tries < 6
        tries += 1

        msg = consume_with_retry(cons1) || consume_with_retry(cons2)
        next if !msg

        replies << msg.value
        replies.uniq!
      end

      assert_equal msgs.sort, replies.sort
    end
  end

  def test_consumer_group_rebalance
    with_new_topic do |topic|
      group_id = rand_id(:cgroup)
      cons1 = Rafka::Consumer.new(CLIENT_DEFAULTS.merge(topic: topic, group: group_id, id: "cons1"))
      cons2 = Rafka::Consumer.new(CLIENT_DEFAULTS.merge(topic: topic, group: group_id, id: "cons2"))
      msg1 = "hi"
      msg2 = "hello"

      start_consumer!(cons1)
      produce_and_flush!(@prod, topic, msg1)
      assert_rafka_msg_equal msg1, consume_with_retry(cons1)

      # commit offsets and shutdown so that cons2 gets all the partitions
      cons1.quit
      start_consumer!(cons2)

      produce_and_flush!(@prod, topic, msg2)

      incoming = consume_with_retry(cons2)
      assert_rafka_msg incoming

      if incoming.value != msg2
        # it means cons2 was assigned the partition before cons1's offsets
        # were commited
        assert_rafka_msg_equal msg1, incoming
        assert_rafka_msg_equal msg2, consume_with_retry(cons2)
      else
        assert_rafka_msg_equal msg2, incoming
      end
    end
  end

  def test_many_consumers_different_topics
    with_new_topic(consumer: true) do |topic1, cons1|
      with_new_topic(consumer: true) do |topic2, cons2|
        start_consumer!(cons1)
        start_consumer!(cons2)

        @prod.produce(topic1, "I'm Mr. Meeseeks")
        @prod.produce(topic2, "Look at me")
        flush!(@prod)

        assert_rafka_msg_equal "I'm Mr. Meeseeks", consume_with_retry(cons1)
        assert_rafka_msg_equal "Look at me", consume_with_retry(cons2)
      end
    end
  end

  def test_produce_wrong_topic
    # TODO(agis): first produce should also raise an error. This is a Rafka
    # issue
    @prod.produce("idontexist", "foo")
    @prod.flush

    assert_raises Rafka::ProduceError do
      @prod.produce("idontexist", "foo")
    end
  end
end

puts "\nRunning on #{host_port} " \
     "(Client version #{Rafka::VERSION}, CONSUME_RETRIES=#{CONSUME_RETRIES}, " \
     "CONSUME_TIMEOUT=#{CONSUME_TIMEOUT})..."

$topics = []

MiniTest.after_run do
  puts "Deleting (#{$topics.count}) test topics..."
  $topics.each { |t| delete_kafka_topic!(t) }
end
